# Architecture & Implementation

This document provides detailed information about the design decisions, implementation details, and comparisons with official Prisma adapters.

## Table of Contents

- [Overview](#overview)
- [Architecture](#architecture)
- [Implementation Details](#implementation-details)
- [Comparison with Official Adapters](#comparison-with-official-adapters)
- [Design Decisions](#design-decisions)
- [Code Organization](#code-organization)
- [Testing Strategy](#testing-strategy)

## Overview

This adapter implements Prisma's `SqlDriverAdapter` interface for Bun's native `bun:sqlite` API. It provides a zero-dependency solution for using Prisma ORM with SQLite in Bun runtime environments.

### Goals

1. **Zero Dependencies**: Use only Bun's native APIs
2. **Full Compatibility**: Pass 100% of Prisma's driver adapter test suite
3. **Production Ready**: Handle all edge cases, errors, and type conversions
4. **Performance**: Leverage Bun's native performance characteristics
5. **Maintainability**: Follow official Prisma adapter patterns

## Architecture

### High-Level Structure

```
┌─────────────────────────────────────┐
│       Prisma Client                 │
│   (Generated by Prisma CLI)         │
└────────────┬────────────────────────┘
             │
             │ SqlDriverAdapter Interface
             │
┌────────────▼────────────────────────┐
│   PrismaBunSQLite (Factory)         │
│   - Creates adapter instance        │
│   - Configures SQLite PRAGMAs       │
└────────────┬────────────────────────┘
             │
┌────────────▼────────────────────────┐
│   BunSQLiteAdapter                  │
│   - Implements SqlDriverAdapter     │
│   - Manages transactions            │
│   - Executes scripts (migrations)   │
└────────────┬────────────────────────┘
             │
┌────────────▼────────────────────────┐
│   BunSQLiteQueryable (Base)         │
│   - queryRaw implementation         │
│   - executeRaw implementation       │
│   - Type conversion logic           │
└────────────┬────────────────────────┘
             │
┌────────────▼────────────────────────┐
│   BunSQLiteTransaction              │
│   - Transaction-specific methods    │
│   - commit() / rollback()           │
└─────────────────────────────────────┘
```

### Class Hierarchy

```typescript
BunSQLiteQueryable (base class)
├── BunSQLiteAdapter (main adapter)
└── BunSQLiteTransaction (transaction handler)

PrismaBunSQLite (factory)
```

## Implementation Details

### 1. Type System

The adapter uses Prisma's type system from `@prisma/driver-adapter-utils`:

```typescript
import {
  ColumnTypeEnum,
  type ArgType,
  type ColumnType,
  type SqlQuery,
  type SqlResultSet,
  // ... more types
} from "@prisma/driver-adapter-utils";
```

### 2. Column Type Detection

**Algorithm** (lines 347-385 in `src/bunsqlite-adapter.ts`):

1. **Extract table names** from SQL using regex:
   ```typescript
   const tablePattern = /(?:FROM|JOIN|INTO|UPDATE)\s+(?:`?\w+`?\.)?[`"']?(\w+)[`"']?/gi;
   ```
   - Matches: `FROM User`, `JOIN Post`, `INSERT INTO \`main\`.\`User\``
   - Handles: backticks, quotes, schema-qualified names

2. **Query PRAGMA** for each table:
   ```typescript
   const schema = this.db.prepare(`PRAGMA table_info("${tableName}")`).all();
   ```
   - Returns: `[{ name: "id", type: "INTEGER", ... }, ...]`

3. **Map declared types** using `mapDeclType()`:
   ```typescript
   "INTEGER" → ColumnTypeEnum.Int32
   "TEXT" → ColumnTypeEnum.Text
   "BLOB" → ColumnTypeEnum.Bytes
   // ... etc
   ```

4. **Infer missing types** from actual data:
   ```typescript
   typeof value === "bigint" → ColumnTypeEnum.Int64
   value instanceof ArrayBuffer → ColumnTypeEnum.Bytes
   // ... etc
   ```

**Why PRAGMA instead of `stmt.columns()`?**
- Gives schema-declared types, not inferred types
- Works with complex queries (JOINs, subqueries)
- More accurate for type coercion

### 3. Argument Mapping

The `mapArg()` function (lines 201-256) converts Prisma types to SQLite types:

```typescript
function mapArg(arg: unknown, argType: ArgType, options?: PrismaBunSqlite3Options)
```

**Key Conversions:**

| Input Type | ArgType | Output |
|------------|---------|--------|
| `boolean` | any | `1` or `0` |
| `"123"` | `int` | `123` (number) |
| `"3.14"` | `float` | `3.14` (number) |
| `"12345678901234"` | `bigint` | `12345678901234n` (BigInt) |
| `Date` | `datetime` | ISO8601 string or Unix timestamp |
| `"aGVsbG8="` | `bytes` | `Buffer` (from base64) |
| `[104,101,108,108,111]` | `bytes` | `Buffer` |

**DateTime Handling:**

```typescript
if (arg instanceof Date) {
  const format = options?.timestampFormat ?? "iso8601";
  switch (format) {
    case "unixepoch-ms":
      return arg.getTime();  // Unix timestamp in milliseconds
    case "iso8601":
      return arg.toISOString().replace("Z", "+00:00");  // ISO8601
  }
}
```

### 4. Row Mapping

The `mapRow()` function (lines 129-187) converts SQLite results to Prisma format:

**Key Transformations:**

```typescript
// BLOB → Array of numbers
if (value instanceof ArrayBuffer || value instanceof Buffer) {
  result[i] = Array.from(new Uint8Array(value));
}

// Float → Int (truncate)
if (typeof value === "number" &&
    (columnTypes[i] === ColumnTypeEnum.Int32 || columnTypes[i] === ColumnTypeEnum.Int64) &&
    !Number.isInteger(value)) {
  result[i] = Math.trunc(value);
}

// Unix timestamp → ISO8601
if ((typeof value === "number" || typeof value === "bigint") &&
    columnTypes[i] === ColumnTypeEnum.DateTime) {
  result[i] = new Date(Number(value)).toISOString();
}

// BigInt → String
if (typeof value === "bigint") {
  result[i] = value.toString();
}
```

### 5. Error Handling

The `convertDriverError()` function (lines 262-280) maps SQLite errors to Prisma error formats:

```typescript
switch (error.code) {
  case "SQLITE_BUSY":
    return { kind: "SocketTimeout", ... };

  case "SQLITE_CONSTRAINT_UNIQUE":
  case "SQLITE_CONSTRAINT_PRIMARYKEY":
    return { kind: "UniqueConstraintViolation", constraint: { fields }, ... };

  case "SQLITE_CONSTRAINT_NOTNULL":
    return { kind: "NullConstraintViolation", constraint: { fields }, ... };

  case "SQLITE_CONSTRAINT_FOREIGNKEY":
  case "SQLITE_CONSTRAINT_TRIGGER":
    return { kind: "ForeignKeyConstraintViolation", ... };

  default:
    // Message-based fallbacks for "no such table", "no such column", etc.
}
```

**Field Extraction:**

```typescript
// Extract field names from error message
// "UNIQUE constraint failed: User.email" → ["email"]
const fields = message
  .split("constraint failed: ")[1]
  ?.split(", ")
  .map((field) => field.split(".").pop()!);
```

### 6. Transaction Management

**Manual BEGIN/COMMIT/ROLLBACK** (lines 444-482):

```typescript
async startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction> {
  // SQLite only supports SERIALIZABLE
  if (isolationLevel && isolationLevel !== "SERIALIZABLE") {
    throw new DriverAdapterError({ kind: "InvalidIsolationLevel", ... });
  }

  // Begin transaction
  this.db.run("BEGIN DEFERRED");
  this.transactionActive = true;

  return new BunSQLiteTransaction(this.db, options, this.adapterOptions, onComplete);
}
```

**Transaction Object:**

```typescript
class BunSQLiteTransaction extends BunSQLiteQueryable implements Transaction {
  async commit(): Promise<void> {
    this.db.run("COMMIT");
    this.onComplete();  // Reset transactionActive flag
  }

  async rollback(): Promise<void> {
    this.db.run("ROLLBACK");
    this.onComplete();
  }
}
```

**Why `usePhantomQuery: true`?**
- Required for Prisma to work with manual transaction management
- Official adapter uses same approach with better-sqlite3

### 7. Script Execution

Uses native `db.exec()` for migrations (lines 515-522):

```typescript
async executeScript(script: string): Promise<void> {
  try {
    // Use native exec() which properly handles multiple statements
    this.db.exec(script);
  } catch (error: any) {
    throw new DriverAdapterError(convertDriverError(error));
  }
}
```

**Why `db.exec()` instead of splitting by semicolons?**
- Handles semicolons inside strings correctly
- Handles multi-line statements
- Native SQLite parsing
- Matches official adapter behavior

### 8. Factory Pattern

The `PrismaBunSQLite` factory (lines 588-611):

```typescript
export class PrismaBunSQLite {
  readonly provider = "sqlite" as const;
  readonly adapterName = "@prisma/adapter-bunsqlite";

  async connect(): Promise<SqlDriverAdapter> {
    const db = new Database(this.dbPath);

    // Configure SQLite for optimal Prisma usage
    db.run("PRAGMA foreign_keys = ON");      // Required for cascades
    db.run("PRAGMA busy_timeout = 5000");    // Handle locks
    db.run("PRAGMA journal_mode = WAL");     // Performance

    return new BunSQLiteAdapter(db, this.options);
  }
}
```

## Comparison with Official Adapters

### vs `@prisma/adapter-better-sqlite3`

| Feature | better-sqlite3 | bun:sqlite (ours) |
|---------|----------------|-------------------|
| **Runtime** | Node.js | Bun |
| **API Type** | Synchronous | Synchronous |
| **Dependencies** | `better-sqlite3` (native) | Zero (Bun built-in) |
| **executeScript** | `db.exec()` | `db.exec()` ✅ |
| **Error Codes** | String codes | String codes ✅ |
| **Argument Mapping** | `mapArg()` | `mapArg()` ✅ |
| **Boolean Conversion** | `1/0` | `1/0` ✅ |
| **Transaction Method** | Manual BEGIN/COMMIT | Manual BEGIN/COMMIT ✅ |
| **Transaction Safety** | `async-mutex` library | Simple `transactionActive` flag |
| **Column Detection** | `stmt.columns()` API | `PRAGMA table_info()` |
| **DateTime Format** | Options support | Options support ✅ |

**Key Differences:**

1. **Transaction Locking**:
   - better-sqlite3: Uses `async-mutex` library to prevent concurrent transactions
   - Ours: Simple `transactionActive` boolean flag
   - **Rationale**: SQLite is single-threaded anyway; simpler approach works fine

2. **Column Type Detection**:
   - better-sqlite3: `stmt.columns()` returns column metadata from better-sqlite3
   - Ours: `PRAGMA table_info()` queries schema directly
   - **Rationale**: PRAGMA gives schema-declared types, more accurate

### vs `@prisma/adapter-libsql`

| Feature | libsql | bun:sqlite (ours) |
|---------|--------|-------------------|
| **Runtime** | Node.js or Bun | Bun only |
| **API Type** | Async (can be networked) | Sync (local only) |
| **Network Support** | ✅ (Turso, remote) | ❌ (local file only) |
| **Dependencies** | `@libsql/client` | Zero |
| **Connection** | URL-based | File path |
| **Transaction** | Automatic via libsql | Manual BEGIN/COMMIT |

**When to use which:**

- **Use libsql** if you need networked SQLite (Turso), edge deployment
- **Use bun:sqlite** for local-only apps, maximum performance, zero deps

## Design Decisions

### 1. Why Manual Transaction Management?

**Decision**: Use manual `BEGIN`/`COMMIT`/`ROLLBACK` instead of `db.transaction()`

**Reasoning**:
- Matches official better-sqlite3 adapter pattern
- Prisma expects to control transaction lifecycle
- `db.transaction()` returns a function, incompatible with Prisma's API
- All tests pass with manual approach

**Code**:
```typescript
// ❌ Can't use this - returns a function
const txFunc = db.transaction(() => {
  db.run("INSERT ...");
  db.run("UPDATE ...");
});
txFunc(); // Executes

// ✅ Instead use this - Prisma-compatible
db.run("BEGIN");
db.run("INSERT ...");
db.run("UPDATE ...");
db.run("COMMIT");
```

### 2. Why `usePhantomQuery: true`?

**Decision**: Set `usePhantomQuery: true` in transaction options

**Reasoning**:
- Required for Prisma's transaction protocol with manual BEGIN/COMMIT
- Changing to `false` caused "Transaction already closed" errors
- Official better-sqlite3 adapter also uses manual transactions (though with different mechanism)

### 3. Why PRAGMA for Column Types?

**Decision**: Use `PRAGMA table_info()` instead of `stmt.columns()`

**Reasoning**:
- bun:sqlite doesn't expose `stmt.columns()` API
- PRAGMA gives schema-declared types, not runtime-inferred
- More accurate for type coercion (e.g., BLOB columns)
- Works with all query types (SELECT, INSERT, etc.)

### 4. Why String Error Codes?

**Decision**: Use string codes (`"SQLITE_CONSTRAINT_UNIQUE"`) not numeric

**Reasoning**:
- bun:sqlite provides string codes natively
- More readable and maintainable
- Matches better-sqlite3 adapter exactly
- No need for numeric code mappings

### 5. Why Options Support?

**Decision**: Add `PrismaBunSqlite3Options` with `timestampFormat`

**Reasoning**:
- Matches official adapter API
- Some users prefer Unix timestamps over ISO8601
- Allows future extensibility
- Zero overhead if not used

## Code Organization

### File Structure

```
src/
└── bunsqlite-adapter.ts    # Main adapter implementation (611 lines)
    ├── Types (lines 1-22)
    ├── Type Mapping (lines 24-92)
    ├── Row Conversion (lines 129-187)
    ├── Argument Mapping (lines 197-256)
    ├── Error Conversion (lines 262-349)
    ├── BunSQLiteQueryable (lines 354-467)
    ├── BunSQLiteTransaction (lines 473-497)
    ├── BunSQLiteAdapter (lines 505-583)
    └── PrismaBunSQLite Factory (lines 588-611)

tests/
├── common/
│   └── test-suite.ts       # Shared test suite (51 tests)
├── bunsqlite-adapter.test.ts  # Runs tests with bun:sqlite
└── libsql-adapter.test.ts     # Runs tests with libsql (baseline)

prisma/
├── schema.prisma           # Test schema
└── generated/              # Generated Prisma Client
```

### Key Functions

| Function | Lines | Purpose |
|----------|-------|---------|
| `mapDeclType()` | 27-69 | Maps SQLite type names to Prisma ColumnType |
| `inferColumnType()` | 74-92 | Infers column type from runtime value |
| `getColumnTypes()` | 97-124 | Combines declared + inferred types |
| `mapRow()` | 129-187 | Converts SQLite row to Prisma format |
| `mapArg()` | 201-256 | Converts Prisma arg to SQLite format |
| `convertDriverError()` | 262-349 | Maps SQLite errors to Prisma errors |
| `getColumnTypesForQuery()` | 430-467 | Detects column types via PRAGMA |

## Testing Strategy

### Test Structure

**Shared Test Suite** (`tests/common/test-suite.ts`):
- 51 comprehensive tests
- Run against both libsql and bunsqlite adapters
- Ensures 100% compatibility

**Test Categories**:

1. **CRUD Operations** (12 tests)
   - create, findUnique, findMany, findFirst
   - update, updateMany, delete, deleteMany
   - upsert, count

2. **Relations** (6 tests)
   - Nested creates
   - Include queries
   - Cascade deletes

3. **Filtering & Querying** (9 tests)
   - Where clauses
   - OrderBy, pagination
   - Distinct

4. **Aggregations** (3 tests)
   - count(), aggregate(), groupBy()

5. **Transactions** (3 tests)
   - Interactive commit
   - Interactive rollback
   - Sequential

6. **Raw Queries** (4 tests)
   - $queryRaw SELECT
   - $executeRaw INSERT/UPDATE/DELETE

7. **Type Coercion** (7 tests)
   - DateTime, BigInt, Boolean
   - Decimal, JSON, Bytes
   - Null handling

8. **Error Handling** (4 tests)
   - P2002 (unique constraint)
   - P2003 (foreign key)
   - P2025 (record not found)
   - P2011 (null constraint)

9. **Edge Cases** (6 tests)
   - Empty strings
   - Large numbers
   - Special characters
   - Concurrent operations

### Running Tests

```bash
# All tests (both adapters)
bun test

# BunSQLite only
bun test tests/bunsqlite-adapter.test.ts

# LibSQL only (baseline)
bun test tests/libsql-adapter.test.ts

# Verbose output
bun test --verbose
```

### Test Results

```
✅ BunSQLite: 51/51 tests passing
✅ LibSQL:    51/51 tests passing
```

## Performance Considerations

### Optimizations

1. **Prepared Statements**: All queries use `db.prepare()`
2. **WAL Mode**: Enabled by default for better concurrency
3. **Type Caching**: Column types cached per query
4. **Direct API**: No middleware, direct `bun:sqlite` calls

### Benchmarks

(TODO: Add benchmarks comparing with better-sqlite3 and libsql)

## Future Improvements

### Potential Enhancements

1. **Connection Pooling**: Not needed for SQLite, but could add for compatibility
2. **Streaming Results**: For very large result sets
3. **Custom PRAGMA Settings**: Allow users to configure more PRAGMAs
4. **Performance Metrics**: Built-in query timing
5. **Shadow Database Support**: For migrations (like better-sqlite3 adapter)

### Known Limitations

1. **SQLite Constraints**: Inherits all SQLite limitations (single writer, no network, etc.)
2. **Decimal Precision**: Limited by SQLite's lack of native decimal type
3. **Transaction Isolation**: Only SERIALIZABLE (SQLite limitation)

## Contributing

When contributing, please:

1. **Read this document** to understand design decisions
2. **Run all tests** before submitting PR
3. **Add tests** for new features
4. **Follow existing patterns** (match official adapter style)
5. **Update documentation** if changing behavior

## References

- [Prisma Driver Adapters Docs](https://www.prisma.io/docs/orm/overview/databases/database-drivers)
- [Bun SQLite API](https://bun.sh/docs/api/sqlite)
- [SQLite Documentation](https://www.sqlite.org/docs.html)
- [Official better-sqlite3 Adapter](https://github.com/prisma/prisma/tree/main/packages/adapter-better-sqlite3)
- [Official libsql Adapter](https://github.com/prisma/prisma/tree/main/packages/adapter-libsql)
